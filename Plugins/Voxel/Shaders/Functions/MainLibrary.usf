// Copyright Voxel Plugin, Inc. All Rights Reserved.

#include "Common.ush"

void HashInt(uint Hash, out float4 Color)
{
	Color = HashInt(Hash);
}
void HashFloat(float Hash, out float4 Color)
{
	Color = HashInt(asuint(Hash));
}

// Texture should be a texture parameter named VoxelTextureAtlas_<Name>Texture
// Index should be a scalar parameter named VoxelTextureAtlas_<Name>Index
[Prefix = VoxelTextureAtlas_]
void Voxel_GetCubicGreedyColor(
	FMaterialPixelParameters Parameters,
	Texture2D<float4> Texture,
	const int Index,
	[Expose, Category="VOXEL_INTERNAL"]
	const int TextureSizeX,
	out float4 Color)
{
	// Parameters.TexCoords[1]

	const int2 UVs = GetCubicGreedyUVs(Parameters, Index, TextureSizeX);
	Color = Texture[UVs];
}

// Texture should be a texture parameter named VoxelTextureAtlas_<Name>Texture
// Index should be a scalar parameter named VoxelTextureAtlas_<Name>Index
[Prefix = VoxelTextureAtlas_]
void Voxel_GetCubicGreedyIndex(
	FMaterialPixelParameters Parameters,
	Texture2D<float> Texture,
	const int Index,
	[Expose, Category="VOXEL_INTERNAL"]
	const int TextureSizeX,
	out float OutIndex)
{
	// Parameters.TexCoords[1]

	const int2 UVs = GetCubicGreedyUVs(Parameters, Index, TextureSizeX);
	OutIndex = asuint(Texture[UVs]);
}

// Texture should be a texture parameter named VoxelTextureAtlas_<Name>Texture
// Index should be a scalar parameter named VoxelTextureAtlas_<Name>Index
[Prefix = VoxelTextureAtlas_]
void Voxel_GetCubicGreedyScalar(
	FMaterialPixelParameters Parameters,
	Texture2D<float> Texture,
	const int Index,
	[Expose, Category="VOXEL_INTERNAL"]
	const int TextureSizeX,
	out float Scalar)
{
	// Parameters.TexCoords[1]

	const int2 UVs = GetCubicGreedyUVs(Parameters, Index, TextureSizeX);
	Scalar = Texture[UVs];
}

[Prefix = VoxelDetailTextures_]
void Voxel_GetDetailTextures(
	FMaterialPixelParameters Parameters,
	[Expose, Category="Voxel Generated Function Parameters"] float Enable = 0,
	[Expose, Category="Voxel Generated Function Parameters"] float VoxelSize,
	[Expose, Category="Voxel Generated Function Parameters"] int ChunkSize,
	[Expose, Category="Voxel Generated Function Parameters"] int NumCellsPerSide,
	[Expose, Category="Voxel Generated Function Parameters"] int TextureSize,
	[Expose, Category="Voxel Generated Function Parameters"] Texture2D IndirectionTexture,
	out float IsEnabled,
	out float2 UVs)
{
	BRANCH
	if (Enable == 0)
	{
		IsEnabled = Enable;
		UVs = 0;
		return;
	}
	IsEnabled = 1.f;

	const float3 PositionInChunk = LWCMultiply(GetWorldPosition_NoMaterialOffsets(Parameters), GetPrimitiveDataFromParameters(Parameters).WorldToLocal) / VoxelSize;
	const float3 CellPosition = clamp(floor(PositionInChunk), 0, ChunkSize - 1);
	uint CellIndex = SampleTexture2D_UINT(IndirectionTexture, uint2(CellPosition.x, CellPosition.y + ChunkSize * CellPosition.z));

	const uint Direction = CellIndex >> 14;
	CellIndex &= ~(3u << 14);

	UVs = float2(CellIndex % NumCellsPerSide, CellIndex / NumCellsPerSide) * TextureSize;

	float3 Delta = PositionInChunk - CellPosition;

	float2 LocalDelta = Direction == 0
		? Delta.yz
		: Direction == 1
		? Delta.xz
		: Delta.xy;

	// Skip 0.5 on each side to avoid leaking
	UVs += 0.5f + LocalDelta * (TextureSize - 1);

	UVs /= NumCellsPerSide * TextureSize;
}

void Voxel_OctahedronToUnitVector(
	float2 Octahedron,
	out float3 UnitVector)
{
	UnitVector = OctahedronToUnitVector(Octahedron * 2.f - 1.f);
}

void Voxel_GetCubicGraphPreview(
	FMaterialPixelParameters Parameters,
	[Expose] float MipLevel,
	[Expose] int TextureSize,
	[Expose] Texture2D ColorTexture,
	[Expose] float OffsetX,
	[Expose] float OffsetY,
	[Expose] float Scale,
	out float ScalarId,
	out float FaceId,
	out float3 UV,
	out float Level)
{
	Level = MipLevel;

	const float2 TexCoords = Parameters.TexCoords[0];
	const uint2 SampleUV = floor(TexCoords * TextureSize);

	const uint Color = SampleTexture2D_UINT(ColorTexture, SampleUV);
	const uint R = (Color >> 16) & 0xFF;
	const uint G = (Color >> 8 ) & 0xFF;
	const uint B = (Color >> 0 ) & 0xFF;
	const uint A = (Color >> 24) & 0xFF;

	ScalarId = R + G * 255;
	FaceId = B + A * 255;

	UV = float3(OffsetX + TexCoords.x * Scale, OffsetY + TexCoords.y * Scale, FaceId);
	UV.y = 1 - UV.y;
}

// Useful when you want to blend two worldspace normals
// Typically, VertexNormal is your vertex normal, BaseNormal the voxel detail texture normal and DetailNormal your actual normalmap
void Voxel_BlendWorldspaceNormals(
	float3 VertexNormal,
	float3 BaseNormal,
	float3 DetailNormal,
	out float3 Result)
{
	// See https://computergraphics.stackexchange.com/questions/2342/how-to-blend-world-space-normals

	const float3 s = VertexNormal;
	const float3 t = BaseNormal;
	const float3 u = DetailNormal;

    // Build the shortest-arc quaternion
    const float4 q = float4(cross(s, t), dot(s, t) + 1) / sqrt(2 * (dot(s, t) + 1));

    // Rotate the normal
    Result = u * (q.w * q.w - dot(q.xyz, q.xyz)) + 2 * q.xyz * dot(q.xyz, u) + 2 * q.w * cross(q.xyz, u);
}

// @param	Displacement	Between -1 and 1
[Prefix = VoxelDetailTextures_]
void Voxel_GetMaterialLayer2x_3WayBlend(
	FMaterialPixelParameters Parameters,
	[Expose, Category="Voxel Generated Function Parameters"] uint NumCellsPerSide,
	[Expose, Category="Voxel Generated Function Parameters"] uint TextureSize,
	[Expose, Category="Voxel Generated Function Parameters"] Texture2D MaterialLayer2xTexture,
	[Expose] float PreviewLayer,
	float2 Displacement = 0,
	out float Layer0,
	out float Layer1,
	out float Layer2,
	out float Alpha0,
	out float Alpha1,
	out float Alpha2)
{
#if !VOXEL_MARCHING_CUBE_VERTEX_FACTORY
	Layer0 = PreviewLayer;
	Layer1 = 0;
	Layer2 = 0;
	Alpha0 = 0;
	Alpha1 = 0;
	Alpha2 = 0;
	return;
#endif

	const float2 SafeDisplacement = clamp(Displacement, -1.f, 1.f) / 2.f;
	const float2 TexCoords = SafeDisplacement / (NumCellsPerSide * TextureSize) + Parameters.TexCoords[1];
	const uint4 Packed4 = asuint(MaterialLayer2xTexture.GatherRed(INTELLISENSE_HIDE(MaterialLayer2xTextureSampler, ) TexCoords));

	// Hack to hide frac precision errors
	const float Hack = 0.50198f;
	const float4 GatherAlphas = GetGatherAlphas(TexCoords, NumCellsPerSide * TextureSize, Hack);

	uint Packed[8];

	Packed[0] = Packed4[0] & 0xFFFF;
	Packed[1] = Packed4[1] & 0xFFFF;
	Packed[2] = Packed4[2] & 0xFFFF;
	Packed[3] = Packed4[3] & 0xFFFF;

	Packed[4] = Packed4[0] >> 16;
	Packed[5] = Packed4[1] >> 16;
	Packed[6] = Packed4[2] >> 16;
	Packed[7] = Packed4[3] >> 16;

	Packed[0] = (uint(floor(ByteToFloat(Packed[0] >> 8) * GatherAlphas[0] * 1048575.999f)) << 8) | (Packed[0] & 0xFF);
	Packed[1] = (uint(floor(ByteToFloat(Packed[1] >> 8) * GatherAlphas[1] * 1048575.999f)) << 8) | (Packed[1] & 0xFF);
	Packed[2] = (uint(floor(ByteToFloat(Packed[2] >> 8) * GatherAlphas[2] * 1048575.999f)) << 8) | (Packed[2] & 0xFF);
	Packed[3] = (uint(floor(ByteToFloat(Packed[3] >> 8) * GatherAlphas[3] * 1048575.999f)) << 8) | (Packed[3] & 0xFF);
	Packed[4] = (uint(floor(ByteToFloat(Packed[4] >> 8) * GatherAlphas[0] * 1048575.999f)) << 8) | (Packed[4] & 0xFF);
	Packed[5] = (uint(floor(ByteToFloat(Packed[5] >> 8) * GatherAlphas[1] * 1048575.999f)) << 8) | (Packed[5] & 0xFF);
	Packed[6] = (uint(floor(ByteToFloat(Packed[6] >> 8) * GatherAlphas[2] * 1048575.999f)) << 8) | (Packed[6] & 0xFF);
	Packed[7] = (uint(floor(ByteToFloat(Packed[7] >> 8) * GatherAlphas[3] * 1048575.999f)) << 8) | (Packed[7] & 0xFF);

#define SWAP(A, B) \
	FLATTEN \
	if (Packed[A] < Packed[B]) \
	{ \
		const uint Temp = Packed[A]; \
		Packed[A] = Packed[B]; \
		Packed[B] = Temp; \
	}

	SWAP(0, 2);
	SWAP(1, 3);
	SWAP(4, 6);
	SWAP(5, 7);
	SWAP(0, 4);
	SWAP(1, 5);
	SWAP(2, 6);
	SWAP(3, 7);
	SWAP(0, 1);
	SWAP(2, 3);
	SWAP(4, 5);
	SWAP(6, 7);
	SWAP(2, 4);
	SWAP(3, 5);
	SWAP(1, 4);
	SWAP(3, 6);
	SWAP(1, 2);
	SWAP(3, 4);
	SWAP(5, 6);

#undef SWAP

	// Alpha is in high bits to allow comparison without masking

#define GET_ALPHA(Index) ((Packed[Index] >> 8) / 1048575.f)
#define GET_LAYER(Index) (Packed[Index] & 0xFF)
#define WRITE(Index) \
	{ \
		const float Alpha = GET_ALPHA(Index); \
		const uint Layer = GET_LAYER(Index); \
		\
		FLATTEN \
		if (Layer0 != Layer && Layer1 == -1) \
		{ \
			Layer1 = Layer; \
		} \
		FLATTEN \
		if (Layer0 != Layer && Layer1 != Layer && Layer2 == -1) \
		{ \
			Layer2 = Layer; \
		} \
		FLATTEN \
		if (Layer == Layer0) \
		{ \
			Alpha0 += Alpha; \
		} \
		FLATTEN \
		if (Layer == Layer1) \
		{ \
			Alpha1 += Alpha; \
		} \
		FLATTEN \
		if (Layer == Layer2) \
		{ \
			Alpha2 += Alpha; \
		} \
	}

	Layer0 = GET_LAYER(0);
	Layer1 = -1;
	Layer2 = -1;

	Alpha0 = GET_ALPHA(0);
	Alpha1 = 0;
	Alpha2 = 0;

	WRITE(1);
	WRITE(2);
	WRITE(3);
	WRITE(4);
	WRITE(5);
	WRITE(6);
	WRITE(7);

#undef WRITE
#undef GET_LAYER
#undef GET_ALPHA

	const float Sum = Alpha0 + Alpha1 + Alpha2;

	Alpha0 /= Sum;
	Alpha1 /= Sum;
	Alpha2 /= Sum;
}

// Result should be lerp(lerp(lerp(LayerA, LayerB, Alpha0), Alpha1), Alpha2)
// @param	Displacement	Between -1 and 1
[Prefix = VoxelDetailTextures_]
void Voxel_GetMaterialLayer1x_4WayBlend(
	FMaterialPixelParameters Parameters,
	[Expose, Category="Voxel Generated Function Parameters"] uint NumCellsPerSide,
	[Expose, Category="Voxel Generated Function Parameters"] uint TextureSize,
	[Expose, Category="Voxel Generated Function Parameters"] Texture2D MaterialLayer1xTexture,
	[Expose] float PreviewLayer,
	float2 Displacement = 0,
	out float LayerA,
	out float LayerB,
	out float LayerC,
	out float LayerD,
	out float Alpha0,
	out float Alpha1,
	out float Alpha2)
{
#if !VOXEL_MARCHING_CUBE_VERTEX_FACTORY
	LayerA = PreviewLayer;
	LayerB = 0;
	LayerC = 0;
	LayerD = 0;
	Alpha0 = 0;
	Alpha1 = 0;
	Alpha2 = 0;
	return;
#endif

	const float2 SafeDisplacement = clamp(Displacement, -1.f, 1.f) / 2.f;
	const float2 TexCoords = SafeDisplacement / (NumCellsPerSide * TextureSize) + Parameters.TexCoords[1];
	uint4 Packed = asuint(MaterialLayer1xTexture.GatherRed(INTELLISENSE_HIDE(MaterialLayer1xTextureSampler, ) TexCoords));

	// Hack to hide frac precision errors
	const float Hack = 0.50198f;
	float4 Alphas = GetGatherAlphas(TexCoords, NumCellsPerSide * TextureSize, Hack);

	// Deterministic order

#define SWAP(A, B) \
	if (Packed[A] < Packed[B]) \
	{ \
		const uint TempLayer = Packed[A]; \
		Packed[A] = Packed[B]; \
		Packed[B] = TempLayer; \
		\
		const float TempAlpha = Alphas[A]; \
		Alphas[A] = Alphas[B]; \
		Alphas[B] = TempAlpha; \
	}

	SWAP(0, 2);
	SWAP(1, 3);
	SWAP(0, 1);
	SWAP(2, 3);
	SWAP(1, 2);

#undef SWAP

	// Sum of Alphas is already 1

	LayerA = Packed[0];
	LayerB = Packed[1];
	LayerC = Packed[2];
	LayerD = Packed[3];

	Alpha0 = Alphas[1] / (Alphas[0] + Alphas[1]);
	Alpha1 = Alphas[2] / (1 - Alphas[3]);
	Alpha2 = Alphas[3];
}

void Voxel_MaterialLayer_GetScalar(
	uint Layer,
	Texture2D ScalarTexture,
	out float Value)
{
	Value = ScalarTexture[uint2(Layer, 0)].r;
}

void Voxel_MaterialLayer_GetVector(
	uint Layer,
	Texture2D ScalarTexture,
	out float4 Value)
{
	Value = ScalarTexture[uint2(Layer, 0)].rgba;
}